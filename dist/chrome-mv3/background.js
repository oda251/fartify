var background=function(){"use strict";var ye=Object.defineProperty;var pe=(K,k,L)=>k in K?ye(K,k,{enumerable:!0,configurable:!0,writable:!0,value:L}):K[k]=L;var y=(K,k,L)=>pe(K,typeof k!="symbol"?k+"":k,L);var H,J,X,Z;function K(n){return n==null||typeof n=="function"?{main:n}:n}const k=n=>{const e=[];return n.forEach(t=>{var d;const s={full:t,name:((d=t.match(/([^\/]+)(?=\.[^\/]+$)|([^\/]+)$/))==null?void 0:d[0])||""};e.push(s)}),e},Q={files:["sounds/fart/06 ブビィッ！.mp3","sounds/fart/57 プゥゥァァ！.mp3","sounds/fart/41 ヴゥィッ！.mp3","sounds/fart/33 ブリリィ、プロォォ.mp3","sounds/fart/27 ポ、ポ、プィィィ！.mp3","sounds/fart/20 ブゥゥ→ビィィィ↑ブゥゥ↓.mp3","sounds/fart/29 ブゥーー！.mp3","sounds/fart/46 ビィィヴゥォォオオオヴァアア！.mp3","sounds/fart/37 プィッ！・・ポピィィ！↑.mp3","sounds/fart/02 ブゥゥゥ！（低音系）.mp3","sounds/fart/10 プリッ！（小さめ）.mp3","sounds/fart/25 ビリリリィ・・ビリィ・・・ブビッ！.mp3","sounds/fart/28 ヴゥボオ、スィィ〜.mp3","sounds/fart/50 ブゥ！.mp3","sounds/fart/43 ブリッ！.mp3","sounds/fart/49 ヴィッ！.mp3","sounds/fart/19 ブリリリィ.mp3","sounds/fart/12 ポスッ！.mp3","sounds/fart/38 ポォウィィィ！！！・・プィィ！.mp3","sounds/fart/42 ブゥー！.mp3","sounds/fart/17 プップッ・・・プリリィ.mp3","sounds/fart/05 ブビッ・・ブビッ・・・ビィー・・・ブリ！.mp3","sounds/fart/15 ブヴィィィ・・・ビィッ！.mp3","sounds/fart/48 ピィァァァ！.mp3","sounds/fart/53 ブゥ…ヴィ！.mp3","sounds/fart/11 ピッ！・・・プーウィィー！.mp3","sounds/fart/44 ブリッ、ピリッ、プリッ！.mp3","sounds/fart/26 ブリリィィリ！.mp3","sounds/fart/45 ブリリィ！ヴルォォ！.mp3","sounds/fart/09 ブゥォッ！.mp3","sounds/fart/52 ブゥヴィ…ヴィリィィ！.mp3","sounds/fart/24 ブリ！・・・ヴィィ.mp3","sounds/fart/23 ビリィ・・ブリィィィィ・・・・・・ブリ.mp3","sounds/fart/31 ブビィィ・・ブロォロォオ！.mp3","sounds/fart/55 プィポッ！.mp3","sounds/fart/54 ヴゥィッチ！.mp3","sounds/fart/56 ヴイッ！.mp3","sounds/fart/03 ブィィィボォォ・・・・・ブゥー！.mp3","sounds/fart/14 ブゥゥゥプリッ！.mp3","sounds/fart/16 ポピッ・・・プリッ・・・ピッ！.mp3","sounds/fart/47 ヴィヴォヴァ！.mp3","sounds/fart/04 ヴィッ・・・ブリリィ・・・ブリィ（若干水気あり）.mp3","sounds/fart/13 プルリィィィィ.mp3","sounds/fart/21 ブィィィィ（ミチミチ）.mp3","sounds/fart/30 プィィー！（すかし気味）.mp3","sounds/fart/32 プッ！クロォロロ・・クリィ・・プリ.mp3","sounds/fart/22 プゥゥゥ！.mp3","sounds/fart/08 ビィボゥオ・・・ビィ！.mp3","sounds/fart/34 ボォォブィィ！・・・ブルルルゥ・・・・ブリィ.mp3","sounds/fart/07 ヴィッー！.mp3","sounds/fart/58 プシッピーピ！.mp3","sounds/fart/18 ブィィィ！.mp3","sounds/fart/36 プゥスゥォォォオ！（すかし）.mp3","sounds/fart/39 ブゥィ！・・・ブィッ！.mp3","sounds/fart/01 ブリッ！.mp3","sounds/fart/35 ブビィィ！.mp3","sounds/fart/40 ブゥィィ！.mp3","sounds/fart/51 ビー！.mp3"]},_={isActivated:{default:!0,fallback:!1},fartMode:{default:"natural",fallback:"natural"},sound:{default:"",fallback:"sounds/fart/01 ブリッ！.mp3"},allSounds:{default:Q.files,fallback:Q.files},probability:{default:.1,fallback:.1},stainColor:{default:"#ffdead",fallback:"#ffdead"}};class O{constructor(e){y(this,"value_");y(this,"get",()=>this.value_);y(this,"set",e=>{this.value_=e});this.value_=e}}const v={isActivated:new O(_.isActivated.default),sound:new O(_.sound.default),allSounds:new O(k(_.allSounds.default)),probability:new O(_.probability.default),fartMode:new O(_.fartMode.default),config:{get:()=>({isActivated:v.isActivated.get(),sound:v.sound.get(),probability:v.probability.get(),mode:v.fartMode.get()}),set:n=>{v.isActivated.set(n.isActivated),v.sound.set(n.sound),v.probability.set(n.probability),v.fartMode.set(n.mode)}}};var B=Object.prototype.hasOwnProperty;function U(n,e){var t,s;if(n===e)return!0;if(n&&e&&(t=n.constructor)===e.constructor){if(t===Date)return n.getTime()===e.getTime();if(t===RegExp)return n.toString()===e.toString();if(t===Array){if((s=n.length)===e.length)for(;s--&&U(n[s],e[s]););return s===-1}if(!t||typeof n=="object"){s=0;for(t in n)if(B.call(n,t)&&++s&&!B.call(e,t)||!(t in e)||!U(n[t],e[t]))return!1;return Object.keys(e).length===s}}return n!==n&&e!==e}const se=new Error("request for lock canceled");var re=function(n,e,t,s){function d(l){return l instanceof t?l:new t(function(f){f(l)})}return new(t||(t=Promise))(function(l,f){function b(g){try{S(s.next(g))}catch(V){f(V)}}function x(g){try{S(s.throw(g))}catch(V){f(V)}}function S(g){g.done?l(g.value):d(g.value).then(b,x)}S((s=s.apply(n,e||[])).next())})};class ne{constructor(e,t=se){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((s,d)=>{const l={resolve:s,reject:d,weight:e,priority:t},f=Y(this._queue,b=>t<=b.priority);f===-1&&e<=this._value?this._dispatchItem(l):this._queue.splice(f+1,0,l)})}runExclusive(e){return re(this,arguments,void 0,function*(t,s=1,d=0){const[l,f]=yield this.acquire(s,d);try{return yield t(l)}finally{f()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(s=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),ie(this._weightedWaiters[e-1],{resolve:s,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(s=>s.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const s=this._weightedWaiters[t-1];if(!s)continue;const d=s.findIndex(l=>l.priority<=e);(d===-1?s:s.splice(0,d)).forEach(l=>l.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function ie(n,e){const t=Y(n,s=>e.priority<=s.priority);n.splice(t+1,0,e)}function Y(n,e){for(let t=n.length-1;t>=0;t--)if(e(n[t]))return t;return-1}var oe=function(n,e,t,s){function d(l){return l instanceof t?l:new t(function(f){f(l)})}return new(t||(t=Promise))(function(l,f){function b(g){try{S(s.next(g))}catch(V){f(V)}}function x(g){try{S(s.throw(g))}catch(V){f(V)}}function S(g){g.done?l(g.value):d(g.value).then(b,x)}S((s=s.apply(n,e||[])).next())})};class ue{constructor(e){this._semaphore=new ne(1,e)}acquire(){return oe(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const F=((J=(H=globalThis.browser)==null?void 0:H.runtime)==null?void 0:J.id)==null?globalThis.chrome:globalThis.browser,ce=le();function le(){const n={local:W("local"),session:W("session"),sync:W("sync"),managed:W("managed")},e=o=>{const r=n[o];if(r==null){const a=Object.keys(n).join(", ");throw Error(`Invalid area "${o}". Options: ${a}`)}return r},t=o=>{const r=o.indexOf(":"),a=o.substring(0,r),i=o.substring(r+1);if(i==null)throw Error(`Storage key should be in the form of "area:key", but received "${o}"`);return{driverArea:a,driverKey:i,driver:e(a)}},s=o=>o+"$",d=(o,r)=>{const a={...o};return Object.entries(r).forEach(([i,u])=>{u==null?delete a[i]:a[i]=u}),a},l=(o,r)=>o??r??null,f=o=>typeof o=="object"&&!Array.isArray(o)?o:{},b=async(o,r,a)=>{const i=await o.getItem(r);return l(i,(a==null?void 0:a.fallback)??(a==null?void 0:a.defaultValue))},x=async(o,r)=>{const a=s(r),i=await o.getItem(a);return f(i)},S=async(o,r,a)=>{await o.setItem(r,a??null)},g=async(o,r,a)=>{const i=s(r),u=f(await o.getItem(i));await o.setItem(i,d(u,a))},V=async(o,r,a)=>{if(await o.removeItem(r),a!=null&&a.removeMeta){const i=s(r);await o.removeItem(i)}},ee=async(o,r,a)=>{const i=s(r);if(a==null)await o.removeItem(i);else{const u=f(await o.getItem(i));[a].flat().forEach(c=>delete u[c]),await o.setItem(i,u)}},te=(o,r,a)=>o.watch(r,a);return{getItem:async(o,r)=>{const{driver:a,driverKey:i}=t(o);return await b(a,i,r)},getItems:async o=>{const r=new Map,a=new Map,i=[];o.forEach(c=>{let m,h;typeof c=="string"?m=c:"getValue"in c?(m=c.key,h={fallback:c.fallback}):(m=c.key,h=c.options),i.push(m);const{driverArea:A,driverKey:M}=t(m),E=r.get(A)??[];r.set(A,E.concat(M)),a.set(m,h)});const u=new Map;return await Promise.all(Array.from(r.entries()).map(async([c,m])=>{(await n[c].getItems(m)).forEach(A=>{const M=`${c}:${A.key}`,E=a.get(M),w=l(A.value,(E==null?void 0:E.fallback)??(E==null?void 0:E.defaultValue));u.set(M,w)})})),i.map(c=>({key:c,value:u.get(c)}))},getMeta:async o=>{const{driver:r,driverKey:a}=t(o);return await x(r,a)},getMetas:async o=>{const r=o.map(u=>{const c=typeof u=="string"?u:u.key,{driverArea:m,driverKey:h}=t(c);return{key:c,driverArea:m,driverKey:h,driverMetaKey:s(h)}}),a=r.reduce((u,c)=>{var m;return u[m=c.driverArea]??(u[m]=[]),u[c.driverArea].push(c),u},{}),i={};return await Promise.all(Object.entries(a).map(async([u,c])=>{const m=await F.storage[u].get(c.map(h=>h.driverMetaKey));c.forEach(h=>{i[h.key]=m[h.driverMetaKey]??{}})})),r.map(u=>({key:u.key,meta:i[u.key]}))},setItem:async(o,r)=>{const{driver:a,driverKey:i}=t(o);await S(a,i,r)},setItems:async o=>{const r={};o.forEach(a=>{const{driverArea:i,driverKey:u}=t("key"in a?a.key:a.item.key);r[i]??(r[i]=[]),r[i].push({key:u,value:a.value})}),await Promise.all(Object.entries(r).map(async([a,i])=>{await e(a).setItems(i)}))},setMeta:async(o,r)=>{const{driver:a,driverKey:i}=t(o);await g(a,i,r)},setMetas:async o=>{const r={};o.forEach(a=>{const{driverArea:i,driverKey:u}=t("key"in a?a.key:a.item.key);r[i]??(r[i]=[]),r[i].push({key:u,properties:a.meta})}),await Promise.all(Object.entries(r).map(async([a,i])=>{const u=e(a),c=i.map(({key:M})=>s(M));console.log(a,c);const m=await u.getItems(c),h=Object.fromEntries(m.map(({key:M,value:E})=>[M,f(E)])),A=i.map(({key:M,properties:E})=>{const w=s(M);return{key:w,value:d(h[w]??{},E)}});await u.setItems(A)}))},removeItem:async(o,r)=>{const{driver:a,driverKey:i}=t(o);await V(a,i,r)},removeItems:async o=>{const r={};o.forEach(a=>{let i,u;typeof a=="string"?i=a:"getValue"in a?i=a.key:"item"in a?(i=a.item.key,u=a.options):(i=a.key,u=a.options);const{driverArea:c,driverKey:m}=t(i);r[c]??(r[c]=[]),r[c].push(m),u!=null&&u.removeMeta&&r[c].push(s(m))}),await Promise.all(Object.entries(r).map(async([a,i])=>{await e(a).removeItems(i)}))},removeMeta:async(o,r)=>{const{driver:a,driverKey:i}=t(o);await ee(a,i,r)},snapshot:async(o,r)=>{var u;const i=await e(o).snapshot();return(u=r==null?void 0:r.excludeKeys)==null||u.forEach(c=>{delete i[c],delete i[s(c)]}),i},restoreSnapshot:async(o,r)=>{await e(o).restoreSnapshot(r)},watch:(o,r)=>{const{driver:a,driverKey:i}=t(o);return te(a,i,r)},unwatch(){Object.values(n).forEach(o=>{o.unwatch()})},defineItem:(o,r)=>{const{driver:a,driverKey:i}=t(o),{version:u=1,migrations:c={}}=r??{};if(u<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const m=async()=>{var ae;const w=s(i),[{value:$},{value:q}]=await a.getItems([i,w]);if($==null)return;const P=(q==null?void 0:q.v)??1;if(P>u)throw Error(`Version downgrade detected (v${P} -> v${u}) for "${o}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${o}: v${P} -> v${u}`);const ge=Array.from({length:u-P},(D,N)=>P+N+1);let C=$;for(const D of ge)try{C=await((ae=c==null?void 0:c[D])==null?void 0:ae.call(c,C))??C}catch(N){throw Error(`v${D} migration failed for "${o}"`,{cause:N})}await a.setItems([{key:i,value:C},{key:w,value:{...q,v:u}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${o} v${u}`,{migratedValue:C})},h=(r==null?void 0:r.migrations)==null?Promise.resolve():m().catch(w=>{console.error(`[@wxt-dev/storage] Migration failed for ${o}`,w)}),A=new ue,M=()=>(r==null?void 0:r.fallback)??(r==null?void 0:r.defaultValue)??null,E=()=>A.runExclusive(async()=>{const w=await a.getItem(i);if(w!=null||(r==null?void 0:r.init)==null)return w;const $=await r.init();return await a.setItem(i,$),$});return h.then(E),{key:o,get defaultValue(){return M()},get fallback(){return M()},getValue:async()=>(await h,r!=null&&r.init?await E():await b(a,i,r)),getMeta:async()=>(await h,await x(a,i)),setValue:async w=>(await h,await S(a,i,w)),setMeta:async w=>(await h,await g(a,i,w)),removeValue:async w=>(await h,await V(a,i,w)),removeMeta:async w=>(await h,await ee(a,i,w)),watch:w=>te(a,i,($,q)=>w($??M(),q??M())),migrate:m}}}}function W(n){const e=()=>{if(F.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(F.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const s=F.storage[n];if(s==null)throw Error(`"browser.storage.${n}" is undefined`);return s},t=new Set;return{getItem:async s=>(await e().get(s))[s],getItems:async s=>{const d=await e().get(s);return s.map(l=>({key:l,value:d[l]??null}))},setItem:async(s,d)=>{d==null?await e().remove(s):await e().set({[s]:d})},setItems:async s=>{const d=s.reduce((l,{key:f,value:b})=>(l[f]=b,l),{});await e().set(d)},removeItem:async s=>{await e().remove(s)},removeItems:async s=>{await e().remove(s)},snapshot:async()=>await e().get(),restoreSnapshot:async s=>{await e().set(s)},watch(s,d){const l=f=>{const b=f[s];b!=null&&(U(b.newValue,b.oldValue)||d(b.newValue??null,b.oldValue??null))};return e().onChanged.addListener(l),t.add(l),()=>{e().onChanged.removeListener(l),t.delete(l)}},unwatch(){t.forEach(s=>{e().onChanged.removeListener(s)}),t.clear()}}}class j{constructor(e){y(this,"key_");y(this,"storage");y(this,"get",async()=>await this.storage.getValue());y(this,"set",async e=>{await this.storage.setValue(e)});this.key_=e.key,this.storage=ce.defineItem(`local:${this.key_}`,e.options)}}const I={isActivated:new j({key:"isActivated",options:{defaultValue:_.isActivated.default,fallback:_.isActivated.fallback}}),sound:new j({key:"sound",options:{defaultValue:_.sound.default,fallback:_.sound.fallback}}),allSounds:new j({key:"allSounds",options:{defaultValue:k(_.allSounds.default),fallback:k(_.allSounds.fallback)}}),probability:new j({key:"probability",options:{defaultValue:_.probability.default,fallback:_.probability.fallback}}),fartMode:new j({key:"fartMode",options:{defaultValue:_.fartMode.default,fallback:_.fartMode.fallback}}),config:{get:async()=>{const[n,e,t,s]=await Promise.all([I.isActivated.get(),I.sound.get(),I.probability.get(),I.fartMode.get()]);return{isActivated:n,sound:e,probability:t,mode:s}},set:async n=>{await Promise.all([I.isActivated.set(n.isActivated),I.sound.set(n.sound),I.probability.set(n.probability),I.fartMode.set(n.mode)])}}},z={name:"Fartify",version:"1.0.0",permissions:["storage","activeTab","background"],web_accessible_resources:[{resources:["sounds/*"],matches:["<all_urls>"]}]}.name;class T{constructor(e){y(this,"namespace");y(this,"GET");y(this,"SET");this.namespace=`${z}:${e}`,this.GET=this.format("GET"),this.SET=this.format("SET")}format(e){return`${this.namespace}:${e}`}toString(){return this.namespace}}class p{}y(p,"config",new T("config")),y(p,"isActivated",new T("is-activated")),y(p,"sound",new T("sound")),y(p,"soundList",new T("sound-list")),y(p,"probability",new T("probability")),y(p,"fartMode",new T("fart-mode")),y(p,"update",new T("update"));const de=n=>n.startsWith(z),fe=()=>{const n=v.allSounds.get(),e=Math.floor(Math.random()*n.length);return n[e].full},me=(n,e)=>{const t=n.type;if(t===p.config.GET)return v.config.get();if(t===p.isActivated.GET)return v.isActivated.get();if(t===p.sound.GET){const s=v.sound.get();return s||fe()}else return t===p.fartMode.GET?v.fartMode.get():t===p.soundList.GET?v.allSounds.get():void 0},he=async(n,e)=>{const t=n.type,s=n.value;if(t===p.config.SET)await I.config.set(s),v.config.set(s);else if(t===p.isActivated.SET)await I.isActivated.set(s),v.isActivated.set(s);else if(t===p.sound.SET)await I.sound.set(s),v.sound.set(s);else if(t===p.fartMode.SET)await I.fartMode.set(s),v.fartMode.set(s);else return},we=K({main:async()=>{const n=await I.config.get();v.config.set(n);const e=await I.allSounds.get();e.sort((t,s)=>t.name.localeCompare(s.name)),v.allSounds.set(e),chrome.runtime.onMessage.addListener(async(t,s,d)=>{if(de(t.type)){const l=me(t);l!==void 0?d(l):await he(t)!==void 0&&d(!0)}}),chrome.tabs.onActivated.addListener(t=>{const s=t.tabId;chrome.tabs.sendMessage(s,{type:p.update.SET,value:v.isActivated.get()})})}});function _e(){}((Z=(X=globalThis.browser)==null?void 0:X.runtime)==null?void 0:Z.id)==null?globalThis.chrome:globalThis.browser;function G(n,...e){}const ve={debug:(...n)=>G(console.debug,...n),log:(...n)=>G(console.log,...n),warn:(...n)=>G(console.warn,...n),error:(...n)=>G(console.error,...n)};let R;try{R=we.main(),R instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(n){throw ve.error("The background crashed on startup!"),n}return R}();
background;
